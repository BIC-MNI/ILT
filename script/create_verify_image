#! /usr/bin/env perl
#---------------------------------------------------------------------------
#@COPYRIGHT :
#             Copyright 1998, Alex P. Zijdenbos
#             McConnell Brain Imaging Centre,
#             Montreal Neurological Institute, McGill University.
#             Permission to use, copy, modify, and distribute this
#             software and its documentation for any purpose and without
#             fee is hereby granted, provided that the above copyright
#             notice appear in all copies.  The author and McGill University
#             make no representations about the suitability of this
#             software for any purpose.  It is provided "as is" without
#             express or implied warranty.
#---------------------------------------------------------------------------- 
#$RCSfile: create_verify_image,v $
#$Revision: 1.7 $
#$Author: alex $
#$Date: 2009-11-08 23:14:43 $
#$State: Exp $
#---------------------------------------------------------------------------

# TO DO:
# 
# *) Allow col specs to change between rows
# *) Allow for any transparent MINC overlay (not only label vols)
# *) Allow for different volume ranging methods
# *) Check all args before processing (e.g., ranging)
# *) Allow x/y/z specs of slices (in addition to s/c/t)
# *) Provide for "intuitive" window/level settings "bright" "dim" etc

use Env qw/ TMPDIR /;
use File::Basename;
use File::Temp qw/ tempdir /;
use Getopt::Tabular;

use Cwd qw/ abs_path getcwd /;

use IO::File;

use ILT::LayoutInclude;
use ILT::LayoutUtils;
use ILT::ProgUtils;

use strict;
use FindBin;
use Switch;

$| = 1;

# User-modifiable globals
my $Verbose = 1;
my $Execute = 1;
my $Clobber = 0;
my $Debug   = 0;
my $TmpDir;

my $ProgramName = fileparse($0);

my($OutFile);
my(@Volumes);
my($Height, $Width) = (0, 0);
my($BGcolor) = 'black';
my($BoundingObject) = undef;
my($BoundingVolume) = undef;
my(@RowSpec);
my(@GlobalRowSpec) = ();
my(@ColSpec) = qw(t-35 t10 t65 s-30 s60 c-90 c-25 c30); 
my $DefaultColsUsed = 1;
my $AutoCols = 0;
my($Transpose) = 0;
my($FileTitle) = 0;

# highest label value allowed. Used when generating objects for surface overlay
my($MAX_LABEL) = 255;

# if given a volume for surface overlay, surfaces generated by marching cubes
# are stored here for reuse across rows ($expanded_label{file.mnc}{label}) 
my(%expanded_label);

# Other globals
my($Usage, $Help, $ModelDir,
   $layout, $n_rows, $n_cols,
   $view, $image_info, $row, $col, @obj_files, @view_dirs,
   @view, @plane_object, 
   $surface_cross_section,
   $bounding_object, $clipped_view, $extra_space_around_bounding_object,
   $object_defining_view, %color_map );

Initialize();

#-----------------------------------------------------------------
#   Create image layout
#-----------------------------------------------------------------

$layout = ($Transpose) ? 
  ILT::ImageLayout->new_grid( $n_cols, $n_rows ) : 
  ILT::ImageLayout->new_grid( $n_rows, $n_cols );
$layout->horizontal_white_space( 3 );
$layout->vertical_white_space( 10 );
$layout->white_space_colour( $BGcolor );
   
#-----------------------------------------------------------------
#   Since clipping is not yet implemented, the following bounding
#   object specificiation is a temporary hack to allow specifying
#   a narrower region of interest than the whole volume
#
#   Actually, it's not really that much of a hack.  Rather than
#   letting the view define itself based on the scene to be rendered
#   it is letting the view defined itself based on some unrelated
#   scene object which represents the region of interest.  This seems
#   like a reasonably valid thing to do.
#-----------------------------------------------------------------

if (defined($BoundingObject)) {
    $bounding_object = ILT::GeometricObject->new( $BoundingObject );
    $extra_space_around_bounding_object = 5;
}

#-----------------------------------------------------------------
#   Create a slice and view for each column
#-----------------------------------------------------------------

for( $col = 0;  $col < $n_cols;  ++$col ) {
    my($plane, $slice, $view) = @{ $ColSpec[$col] };

    $plane_object[$col] = 
      ILT::PlaneObject->new_canonical($plane, $slice);
    $view[$col] = ILT::View->new_canonical($view);
    #   Temporary modification of view to clip it, this will disappear when
    #   clipping is implemented.  You may comment out this line if not desired
    
    if (defined($BoundingObject)) {
	$object_defining_view = 
	  ILT::IntersectionObject->new($plane_object[$col], $bounding_object );
	
	SetClippedView($view[$col],
		       $object_defining_view,
		       $extra_space_around_bounding_object );
    }
}

#-----------------------------------------------------------------
#   Now describe each image in the grid
#-----------------------------------------------------------------

for( $row = 0;  $row < $n_rows;  ++$row )
{
    print "================ Processing row $row =================\n" if ($Verbose);

    #-----------------------------------------------------------------
    #   Create a volume and surface object(s) for each row
    #-----------------------------------------------------------------

    my(%colorSpec) = %{ $RowSpec[$row]{color} };

    my($volume_object) = ILT::VolumeObject->new( $RowSpec[$row]{volume} );
    if ($colorSpec{'type'} eq 'label') {
	$volume_object->interpolation( Nearest_neighbour_interpolation );
    }

    my($volume_overlaySpec) = $RowSpec[$row]{volume_overlay};
    if (defined($volume_overlaySpec)) {
	my($vol_ovl);
	foreach $vol_ovl (@$volume_overlaySpec) {
		if ( $$vol_ovl{'type'} eq 'mnc' ){
			if ($$vol_ovl{'opacity'} ne '' ) {
				die "$ProgramName overlay opacity value '".$$vol_ovl{'opacity'}."' must be a number.\n" if not $$vol_ovl{'opacity'} =~ /[0-9]+(\.[0-9]*)?/;
			}else{
				$$vol_ovl{'opacity'} = 0.5;
			}
			$$vol_ovl{'object'} = ILT::VolumeObject->new($$vol_ovl{'file'});
			$$vol_ovl{'object'}->interpolation( Nearest_neighbour_interpolation );
		}
		else{
			&Getopt::Tabular::SetError("bad_value", "Bad filetype '".$$vol_ovl{'file'}."' -- must be .mnc");
		}

	}
    }

	my($surface_overlaySpec) = $RowSpec[$row]{surface_overlay};
	if (defined($surface_overlaySpec)) {

		# list of surface overlays specs split from minc volume
		my(@split_overlay);

		my($surf_ovl);
		foreach $surf_ovl (@$surface_overlaySpec) {

			if ($$surf_ovl{'type'} eq 'obj') {
				if ($$surf_ovl{'color'} and $$surf_ovl{'color'} ne 'label') {
					$$surf_ovl{'file'} = ColorObject($$surf_ovl{'file'}, $$surf_ovl{'color'});
				}

				$$surf_ovl{'object'} = ILT::GeometricObject->new($$surf_ovl{'file'});
				# no need to split (we're already a surface object file)
				push( @split_overlay, $surf_ovl) ;
			}

			if ($$surf_ovl{'type'} eq 'mnc') {

				%color_map = loadColorMap("${ModelDir}labels.map") if not %color_map;

				# add an overlay for each label in the minc volume

				# get labels
				my $tmp_hist = get_tmp_file( 'csv' );
				my @cmd = ("mincstats", "-clobber", "-quiet", "-none", "-floor", "0.5","-max", "-integer_histogram", "-histogram", $tmp_hist, $$surf_ovl{'file'});
				my @mincstats_output = `@cmd`;

				# die if suspected that this minc file isn't a label volume
				my $greatest_label = $mincstats_output[1];
				chomp $greatest_label;
				die "Too many labels in '$$surf_ovl{'file'}' to overlay surfaces\n" if $greatest_label > $MAX_LABEL;
				
				my $fh = new IO::File $tmp_hist;
				die "Unable to generate discrete histogram for '".$$surf_ovl{'file'}."'\n" if (! defined $fh);

				my ($split_surface, %expanded_ovl);

				LINE:
				while (<$fh>) {
					next LINE if /^\#/;
					#<value> <frequency>
					next if (not /\D*(\d+)\D+(\d+)/ && $1 && $2);

					# don't lose track of any specs given at command line
					%expanded_ovl = %$surf_ovl;

					# keep track of surface extractions for reuse across rows
					$split_surface = $expanded_label{ $$surf_ovl{'file'} }{$1};
					if ( not $split_surface ){
						$split_surface = get_tmp_file( 'obj' );
						&Run( "marching_cubes", $$surf_ovl{'file'}, $split_surface, $1-0.5, $1+0.5 ) && die;
						$expanded_label{ $$surf_ovl{'file'} }{$1} = $split_surface;
					}

					$expanded_ovl{'file'} = $split_surface;
					if ($$surf_ovl{'color'} and $$surf_ovl{'color'} ne 'label') {
						$expanded_ovl{'file'} = ColorObject($expanded_ovl{'file'}, $expanded_ovl{'color'});
					}
					else{
						$expanded_ovl{'file'} = ColorObject($expanded_ovl{'file'}, $color_map{$1});
					}
					$expanded_ovl{'object'} = ILT::GeometricObject->new($expanded_ovl{'file'});
					push( @split_overlay, {%expanded_ovl} );
				}
				$fh->close;

			}
		}
		# set new surface overlays to those split out of minc volume
		@$surface_overlaySpec = @split_overlay ;
	}

    for( $col = 0;  $col < $n_cols;  ++$col )
    {
	#-----------------------------------------------------------------
	#   Create the scene hierarchy for one image as a union of:
	#       a colour-coded intersection of a slice and volume, and
	#       a cross section of a surface (intersection of slice and
	#                                     surface)
	#-----------------------------------------------------------------

	my($slice_object) = ILT::IntersectionObject->new($plane_object[$col],
							 $volume_object);


	my($colour_object) = 
	  ILT::ColourObject->new_volume_colouring($slice_object,
						  $volume_object, 
						  $colorSpec{'map'},
						  $colorSpec{'min'},
						  $colorSpec{'max'});
	
	if (defined($colorSpec{'file'})) {
	    $colour_object->usercc_filename($colorSpec{'file'});
	}

	my($scene_object) = $colour_object;

	if (defined($volume_overlaySpec)) {
	    my(@vol_objovl);
	    my($vol_ovl);
		my($ovl_color);
		foreach $vol_ovl (@$volume_overlaySpec) {
			$ovl_color = defined $$vol_ovl{'color'} ? $$vol_ovl{'color'} : "${ModelDir}labels.map";

			# if rendering as normal volume
			if ( $ovl_color =~ /gr[ae]y/ ||
				 $ovl_color =~ /hot/ ||
				 $ovl_color =~ /spect/ ){

				 # convert to scale
				 switch ( $ovl_color ){
					case /gr[ae]y/ { $ovl_color = Gray_scale; }
					case /hot/     { $ovl_color = Hot_metal_scale; }
					case /spect/   { $ovl_color = Spectral_scale; }
					else           { die "processing color spec for volume overlay"; }
				 }

				#TODO get rid of those undefs
				my @extrema = VolumeRange($$vol_ovl{'file'}, undef, undef);

				$scene_object = 
				ILT::ColourObject->new_volume_colouring($scene_object,
					$$vol_ovl{'object'},
					$ovl_color,
					$extrema[0], $extrema[1] );

			}
			# else map colors based on colorspec (default labels if not defined)
			else{
				$scene_object = 
				ILT::ColourObject->new_volume_colouring($scene_object,
					$$vol_ovl{'object'},
					Usercc_scale,
					0, 255 );

				my $color_map = $ovl_color; 

				# if not a file, treat as a color map string
				if ( ! -f $ovl_color
					&& $ovl_color =~ 
					/((^|,)((\d+:)?([a-zA-Z]+|[0-9]+(\.[0-9]+)?\s+[0-9]+(\.[0-9]+)?+\s+[0-9]+(\.[0-9]+)?+)))+$/){

					# convert to color map file
					$color_map = generate_color_map( $ovl_color ); 
				}
				#if user-specified, there are problems
				elsif( defined $$vol_ovl{'color'} ) {
					warn "Ignoring your volume overlay color spec '$ovl_color'\n";
				}

				$scene_object->usercc_filename($color_map);

			}
			$scene_object->under_colour( "transparent" );
			$scene_object->opacity( $$vol_ovl{'opacity'} );

			if (@vol_objovl) {
				$scene_object = ILT::UnionObject->new( $scene_object, @vol_objovl );
			}
		}
	}
	if (defined($surface_overlaySpec)) {
	    my(@surf_objovl);
	    my($surf_ovl, $line_width);
		foreach $surf_ovl (@$surface_overlaySpec) {
			my($surf_objovl) = 
			ILT::IntersectionObject->new($plane_object[$col],$$surf_ovl{'object'});


			if ( defined($$surf_ovl{'thick'}) ){
				# multiply if first char is 'x'
				$$surf_ovl{'thick'} =~ /^(x?)(.*)/;
				if ( $1 ){
					$line_width = LineWidth($RowSpec[$row]{volume});
					$line_width *= $2;
				}
				else{
					$line_width = $2
				}
			}
			else{
				$line_width = LineWidth($RowSpec[$row]{volume});
			}
			$surf_objovl = ILT::RenderObject->new($surf_objovl);
			$surf_objovl->line_width($line_width);

			push(@surf_objovl, $surf_objovl);
		}

	    if (@surf_objovl) {
		$scene_object = ILT::UnionObject->new( $scene_object, @surf_objovl );
	    }
	}
	
	$image_info = ILT::ImageInfo->new( $scene_object, $view[$col] );
	$image_info->background_colour( $BGcolor );

	
	#-----------------------------------------------------------------
	#   Attach the image info to the layout manager
	#-----------------------------------------------------------------
	
	if ($Transpose) {
	    $layout->image_info( $layout->row_col_to_index($n_cols - $col - 1, $row),
				 $image_info );
	}
	else {
	    $layout->image_info( $layout->row_col_to_index($n_rows - $row - 1, $col),
				 $image_info );
	}
    }
}

#-----------------------------------------------------------------
#   Render the images and create the output file (in rgb)
#-----------------------------------------------------------------

$layout->generate_image( $OutFile, $Width, $Height );

#-----------------------------------------------------------------
#   Convert image to final format if not rgb.
#-----------------------------------------------------------------

if ($OutFile !~ /\.rgb$/) {
    # This works only if the output image is NOT a .rgb, because
    # of a silly bug in mogrify which loses the image header
    # (otherwise we could use ILT/SceneObject/TextObject.pm).

    AnnotateImage( $OutFile, 10, 0 );
}


# ------------------------------ MNI Header ----------------------------------
#@NAME       : AnnotateImage
#@INPUT      : 
#@OUTPUT     : 
#@RETURNS    : 
#@DESCRIPTION: 
#@METHOD     : 
#@GLOBALS    : 
#@CALLS      : 
#@CREATED    : 2006/06/20, Claude Lepage
#@MODIFIED   : 
#-----------------------------------------------------------------------------
sub AnnotateImage ( $$$ ) {

    my $output = shift;
    my $text_width_offset = shift;
    my $text_height_offset = shift;

    # Get global position of images by rows and columns.

    my( @x_pos, @y_pos, @x_size, @y_size );
    my $header = $layout->header();
    my $footer = $layout->footer();
    $layout->compute_image_sizes_and_positions( $Width, $Height, 2 * $header->height(),
                                                2 * $footer->height(), \@x_pos, \@y_pos,
                                                \@x_size, \@y_size );

    # Issue command to draw each label, left justified.
    my $row;
    my @DrawText = ( "-font", "Helvetica" );
    my $DrawSomething = 0;
    for( $row = 0; $row < $n_rows; $row++ ) {
        my $title = $RowSpec[$row]{title};
	if (defined $title && $title) {
	    my $index = $layout->row_col_to_index( $row, 0 );
	    my $x = ($x_pos[$index] + $text_width_offset);
	    my $y = ($y_pos[$index] + $text_height_offset);
	    push(@DrawText, '-annotate', "0x0+${x}+${y}", $title);
	    $DrawSomething = 1;
	}
    }

    if ($DrawSomething) {
	&Run('mogrify', '-stroke', 'green', '-pointsize', 16, @DrawText, $output);
    }
}

# ------------------------------ MNI Header ----------------------------------
#@NAME       : CreateInfoText
#@INPUT      : 
#@OUTPUT     : 
#@RETURNS    : 
#@DESCRIPTION: 
#@METHOD     : 
#@GLOBALS    : 
#@CALLS      : 
#@CREATED    : 98/04/16, Alex Zijdenbos
#@MODIFIED   : 
#-----------------------------------------------------------------------------
sub CreateInfoText
{
   $Usage = <<USAGE;
Usage: $ProgramName <out.{rgb|jpg|tif|...}> [<in.mnc> ...] [options]
       $ProgramName -help
USAGE

   $Help = <<HELP;
$ProgramName 
creates a verification image using David MacDonald\'s ILT library. The default
output image format is IRIX rgb; however, if the output file name does not have
a .rgb extension, ImageMagick\'s \`convert\' will be used to convert it. Note
that the output file and possible input files should be specified before any 
other options.
HELP

   Getopt::Tabular::SetHelp ($Help, $Usage);
}

# ------------------------------ MNI Header ----------------------------------
#@NAME       : SetupArgTables
#@INPUT      : 
#@OUTPUT     : 
#@RETURNS    : 
#@DESCRIPTION: 
#@METHOD     : 
#@GLOBALS    : 
#@CALLS      : 
#@CREATED    : 98/04/16, Alex Zijdenbos
#@MODIFIED   : 
#-----------------------------------------------------------------------------
sub SetupArgTables
{
    my (@args) = 
	(["General options", "section"],
	 ["-verbose|-quiet", "boolean", 1, \$Verbose, "Be verbose"],
	 ["-debug", "boolean", 1, \$Debug, "Be more verbose"],
	 ["-clobber", "boolean", 1, \$Clobber, "Clobber an existing output file"],
	 ["-execute", "boolean", 1, \$Execute, "Execute commands"],
	 ["Specific Options", "section"],
	 ["-background_color", "string", 1, \$BGcolor,
 	  "the `white space' color [default: $BGcolor]", "<color>"],
	 ["-bounding_object", "string", 1, \$BoundingObject,
 	  "the bounding object to use for clipping", "<bounds.obj>"],
	 ["-bounding_volume", "string", 1, \$BoundingVolume,
 	  "the volume to use for trhe extent of the image viewport", "<volume.mnc>"],
	 ["-row", "call", [\@RowSpec], \&ParseRowOption,
	  "specifications for a single row. Multiple rows should be specified using multiple -row options. Multiple overlay specifications are allowed. If no <row.mnc> is specified, input volumes are taken from the global <in.mnc> list.\n                                        --------------------------------------------------------colorspec -- specify the color space in which to render the volume for this row. Automatically calculates min/max pixel intensities over each slice. A mask can be specified (voxels within 0.5 of <binvalue> (default: 1) are included from the mask volume) for min/max pixel intensity calculation which defines the region over which to calculate intensities. Min and/or max intensities can be set explicately.   color:{gray|hot|spect|label|<file>}[:<min>[:<max>]]\n  color:{gray|hot|spect|label|<file>}[:<mask.mnc>[:<binvalue>]]\n--------------------------------------------------------overlayspec -- specify an overlay for the current row (can be *.obj or *.mnc). Surface overlays can be generated from label volumes where a surface is extracted for each label in the volume. The surface line thickness can be explicitly set with <thickness> (see ray_trace) or the create_verify_image default adjusted by a scaling factor (by prefixing <thickness> with an 'x'). Color can be specified for volume overlays as either a path to a custom color map, a comma-separated list of <label>:<value> pairs, or one of 'gray', 'hot' or 'spect' to overlay a regular scan. Note that the bare 'overlay:' spec is kept for backwards compatability; full functionality can be achieved with 'volume_overlay:' and 'surface_overlay:'.\n  volume_overlay:{<label.mnc>[:<opacity>[:<colors>]]}\n  surface_overlay:{(<surf.obj>|<mask.mnc>)[:<color>[:<thickness>]]\n                     overlay:{<surf.obj>[:<color>[:<thickness>]]|<volume.mnc>[:<opacity>[:<colors>]]}\n                                      --------------------------------------------------------titlespec -- specify a title to draw on the current row                title:<string>                                    --------------------------------------------------------", "[<row.mnc>] [colorspec] [overlayspec] [titlespec]"],
	 ["-cols", "call", [\@ColSpec], \&ParseColOption,
	  "comma-separated list of column view specifications. These should be a character or string indicating the plane to view (transverse, sagittal, coronal) followed by a slice position in Talairach coordinates [default: " . join(',', @ColSpec) ."]", "t<slice>|s<slice>|c<slice>[,...]"],
	 ["-autocols", "integer", 1, \$AutoCols,
	  "automatically add <nslices> regularly spaced slices in each direction. These slices are added to any columns specified via -cols", "<nslices>"],
	 ["-height", "integer", 1, \$Height,
	  "height of the output image [default: $Height]", "<height>"],
	 ["-width", "integer", 1, \$Width,
	  "width of the output image [default: $Width]", "<width>"],
	 ["-filetitle", "boolean", 1, \$FileTitle,
	  "add the filename as a title to each row which does not have an explicit title"],
	 ["-transpose|-notranspose", "boolean", 1, \$Transpose,
	  "transpose the image matrix. Note that -width and -height always apply to the final output image, i.e., after the transpose operation if specified [default is -notranspose]"]
	);
    
    \@args;
}

# ------------------------------ MNI Header ----------------------------------
#@NAME       : Initialize
#@INPUT      : 
#@OUTPUT     : 
#@RETURNS    : 
#@DESCRIPTION: 
#@METHOD     : 
#@GLOBALS    : 
#@CALLS      : 
#@CREATED    : 98/04/16, Alex Zijdenbos
#@MODIFIED   :
#-----------------------------------------------------------------------------
sub Initialize
{
   my($argTbl) = SetupArgTables;
   my(@leftOverArgs);

   CreateInfoText();

   GetOptions ($argTbl, \@ARGV, \@leftOverArgs) || die "\n";
   if (@leftOverArgs < 1)  {
       warn $Usage;
       die "Incorrect number of arguments\n";
   }

   $OutFile = shift @leftOverArgs;
   @Volumes = @leftOverArgs;

   $TmpDir = File::Spec->tmpdir();
   $TmpDir = tempdir("${TmpDir}/${ProgramName}_XXXXX", CLEANUP => 1 );

   $ENV{TMPDIR} = $TmpDir;

   if (-e $OutFile ){
	   if ( $Clobber ) {
		   unlink( $OutFile );
	   }
	   else{
		   die "Ouput file $OutFile exists; use -clobber to overwrite\n";
	   }
   }

   my($base, $dir, $ext) = fileparse($OutFile, qr/\.[^\.]*/);

   # Verify dimension specifications
   die "Please specify -width and/or -height\n" 
       if (($Width <= 0) && ($Height <= 0));

   # Get model directory
   $ModelDir = "$FindBin::Bin/../share/ILT/";

   #-----------------------------------------------------------------
   #   Verify row specifications
   #-----------------------------------------------------------------

   # First, insert any global volumes into volume-less rowspecs
   my($row);
   foreach $row (@RowSpec) {
       if (!$$row{volume}) {
	   if (@Volumes) {
	       $$row{volume} = shift @Volumes;
	   }
	   else {
	       die "More row specifications than input volumes\n";
	   }
       }
   }

   # Next, create/add row specifications for any remaining global volumes
   my($volume);
   foreach $volume (@Volumes) {
       print "--- parsing global row options ---\n" if ($Debug);
       ParseRowOption('-row', [ $volume, @GlobalRowSpec ]);
   }   

   # Verify all row specifications and collect smallest bounding box
   # across al volumes
   my @start;
   my @stop;
   $n_rows = @RowSpec;
   my($rowCtr) = 0;

   VolumeBounds($BoundingVolume, \@start, \@stop) if ( defined $BoundingVolume );
   foreach $row (@RowSpec) {
       my($volume) = $$row{volume};
       die "Error parsing row specifications\n" if (!$volume);
       die "Volume $volume is not a file\n" if (! -f $volume);
       
       print "\n----------------------\nRow:     $rowCtr\n" if ($Verbose);
       print "Volume:  $volume\n" if ($Verbose);

       my($title) = $$row{title};
       if ($FileTitle && !defined($$row{title})) {
	   $$row{title} = $volume;
       }
       if (defined($$row{title})) {
	   print "Title:   $$row{title}\n" if ($Verbose);
       }

       # Explicitly decompress volume to avoid repeated decompressions
       $volume = Uncompress($TmpDir, $volume);
       die "Volume $volume is not a file\n" if (! -f $volume);
       $$row{volume} = $volume;

       my($color) = $$row{color};
       if (defined($color)) {
	   ConvertColorSpec($color, $volume);
	   print "Color:   " . HashToStr($color) . "\n" if ($Verbose);
       }

       # Update volume extent
       if ( ! defined $BoundingVolume ){
	   VolumeBounds($volume, \@start, \@stop);
       }

       my($volume_overlays) = $$row{volume_overlay};
       if (defined($volume_overlays)) {
	   my($vol_ovl);
	   foreach $vol_ovl (@$volume_overlays) {
	       $$vol_ovl{'file'} = Uncompress($TmpDir, $$vol_ovl{'file'});
	       die "Overlay $$vol_ovl{'file'} is not a file\n" if (! -f $$vol_ovl{'file'});
	       ($$vol_ovl{'type'}) = $$vol_ovl{'file'} =~ /\.(mnc)/;
	       if (!defined($$vol_ovl{'type'})) {
		   die "Unknown type for volume overlay file " . $$vol_ovl{'file'} . 
		       ". Must be .mnc\n";
	       }
	       print "Overlay: " . HashToStr($vol_ovl) . "\n" if ($Verbose);
	   }
       }

       my($surface_overlays) = $$row{surface_overlay};
       if (defined($surface_overlays)) {
	   my($surf_ovl);
	   foreach $surf_ovl (@$surface_overlays) {
	       $$surf_ovl{'file'} = Uncompress($TmpDir, $$surf_ovl{'file'});
	       die "Overlay $$surf_ovl{'file'} is not a file\n" if (! -f $$surf_ovl{'file'});
	       ($$surf_ovl{'type'}) = $$surf_ovl{'file'} =~ /\.(obj|mnc)/;
	       if (!defined($$surf_ovl{'type'})) {
		   die "Unknown overlay type for file " . $$surf_ovl{'file'} . 
		       ". Must be either .obj or .mnc\n";
	       }
	       print "Overlay: " . HashToStr($surf_ovl) . "\n" if ($Verbose);
	   }
       }

       print "----------------------\n" if ($Verbose);

       $rowCtr++;
   }

   #-----------------------------------------------------------------
   #   Verify column specifications
   #-----------------------------------------------------------------

   if ($AutoCols) {
	   @ColSpec = () if ($DefaultColsUsed);

	   my @plane = qw/ s c t /;
	   foreach my $i (0, 1, 2) {
		   my $extent = $stop[$i] - $start[$i];
		   my $int = $extent/($AutoCols + 1);
		   my $slice = sprintf("%.6f", $start[$i] + $int);
		   for my $j (1..$AutoCols) {
			   push(@ColSpec, "$plane[$i]$slice");
			   $slice = sprintf("%.6f",$slice + $int);	       
		   }
	   }
   }
   
   $n_cols = @ColSpec;
   @ColSpec = map { [ ConvertView($_, \@start, \@stop) ] } @ColSpec;
}

# ------------------------------ MNI Header ----------------------------------
#@NAME       : SetupArgTables
#@INPUT      : 
#@OUTPUT     : 
#@RETURNS    : 
#@DESCRIPTION: 
#@METHOD     : 
#@GLOBALS    : 
#@CALLS      : 
#@CREATED    : 98/04/16, Alex Zijdenbos
#@MODIFIED   : 
#-----------------------------------------------------------------------------
sub ConvertView {
    my($spec, $start, $stop) = @_;

    my(@viewSpec);
    my($view);
    my($plane, $slice) = $spec =~ /^([^\d\-]+)([\d\-\.]+)$/;

    print "Plane: $plane Slice: $slice\n" if ($Verbose);

    if (!defined($plane) || !defined($slice)) {
	die "Couldn't figure out column specification $spec\n";
    }

    if ($plane =~ /^s/) {
	$plane = Sagittal_axis;
	$view  = Right_view;
	if (($slice < $$start[0]) || ($slice > $$stop[0])) {
	    $slice = $$start[0] if ($slice < $$start[0]);
	    $slice = $$stop[0] if ($slice > $$stop[0]);
	    warn "Colspec $spec is out of bounds [$$start[0], $$stop[0]]; truncated to slice $slice\n";
	}
    }
    elsif ($plane =~ /^t/) {
	$plane = Transverse_axis;
	$view  = Top_view;
	if (($slice < $$start[2]) || ($slice > $$stop[2])) {
	    $slice = $$start[2] if ($slice < $$start[2]);
	    $slice = $$stop[2] if ($slice > $$stop[2]);
	    warn "Colspec $spec is out of bounds [$$start[2], $$stop[2]]; truncated to slice $slice\n";
	}
    }
    elsif ($plane =~ /^c/) {
	$plane = Coronal_axis;
	$view  = Back_view;
	if (($slice < $$start[1]) || ($slice > $$stop[1])) {
	    $slice = $$start[1] if ($slice < $$start[1]);
	    $slice = $$stop[1] if ($slice > $$stop[1]);
	    warn "Colspec $spec is out of bounds [$$start[1], $$stop[1]]; truncated to slice $slice\n";
	}
    }
    else {
	die "Unknown plane specification $plane\n";
    }

    ($plane, $slice, $view);
}

#-----------------------------------------------------------------
#   Define the view based on some scene object other than that being
#   rendered.
#-----------------------------------------------------------------

sub SetClippedView( $$$ ) {
    my( $view )        = arg_object( shift, "ILT::View" );
    my( $object_defining_view ) = arg_object( shift, "ILT::SceneObject" );
    my( $extra_space_around_bounding_object ) = arg_real( shift, 0, 1e30 );
    end_args( @_ );
    
    my( $view_copy, @bbox );
    
#--- make a temporary copy of the view
    
    $view_copy = $view->copy();
    
#--- define the default view based on the object
    
    $view_copy->compute_view_for_object( $object_defining_view );
    
#--- explicitly set bounding box of the view, so that it doesn't get
#--- automatically computed
    
    @bbox = $view_copy->bounding_box();
    
    $bbox[0] -= $extra_space_around_bounding_object;
    $bbox[1] += $extra_space_around_bounding_object;
    $bbox[2] -= $extra_space_around_bounding_object;
    $bbox[3] += $extra_space_around_bounding_object;
    $bbox[4] -= $extra_space_around_bounding_object;
    $bbox[5] += $extra_space_around_bounding_object;
    
    $view->bounding_box( @bbox );
}

sub ParseRowOption {
    my($opt, $args, $dest) = @_;

    print "ParseRowOption args: \"" . join(' ', @$args) . "\"\n" if ($Debug);

    my($volume) = shift @$args;

    # Verify that an argument was specified
    if (!defined($volume)) {
	&Getopt::Tabular::SetError("bad_value", "Option $opt must be followed by something");
	return 0;
    }

    # Check whether or not the first argument is a valid minc volume
    if (!IsMincVolume($volume)) {
	unshift @$args, $volume; 
	$volume = 0;
	@GlobalRowSpec = @$args;
    }

    my($color)            = undef;
    my($title)            = undef;
	my($surface_overlays) = undef;
	my($volume_overlays)  = undef;

	while (@$args && ($$args[0] !~ /^-/) && !IsMincVolume($$args[0])) {
		my(@spec) = split(':', shift @$args);

		my($type) = shift @spec;

		print "Type: $type\n" if ($Debug);

		TYPE_PARSE:{
			if ($type eq 'color') {
				if (defined($color)) {
					warn "Warning: ignoring color re-specification \'@spec\'\n";
				}
				else {
					$color         = { 'type' => shift @spec };
					$$color{'min'} = shift @spec if (@spec);
					$$color{'max'} = shift @spec if (@spec);
				}
			} elsif ($type eq 'overlay') {
				# for backwards compatability 
				$spec[0] =~ /\.(obj|mnc)/;

				if ( $1 eq 'obj' ){ $type = 'surface_overlay'; redo TYPE_PARSE;  }
				elsif ( $1 eq 'mnc' ){ $type = 'volume_overlay'; redo TYPE_PARSE; }
				else{
					&Getopt::Tabular::SetError("bad_value", "Bad file type \'" . $spec[0] . "\'; this must be either .obj or .mnc ");
				}

			} elsif ($type eq 'volume_overlay') {
				my($volume_overlay) = { 'file' => shift @spec };
				$$volume_overlay{'opacity'} = shift @spec if (@spec);

				# treat the rest of this spec as a color
				if ( @spec ){
					my $color_spec = join(':',@spec);
					$$volume_overlay{'color'} = join(':',@spec);
				}

				push(@$volume_overlays, $volume_overlay);
			} elsif ( $type eq 'surface_overlay' ) {
				my($surface_overlay) = {'file' => shift @spec };
				$$surface_overlay{'color'} = shift @spec if (@spec);
				$$surface_overlay{'thick'} = shift @spec if (@spec);

				push(@$surface_overlays, $surface_overlay);
			} elsif ($type eq 'title') {
				$title = shift @spec;
			} else {
				&Getopt::Tabular::SetError("bad_value", "Unknown specification \'" . join(':', @spec) . "\'; this must be one of {overlay:|color:|volume_overlay|:surface_overlay:|title:}");
				return 0;
			}
		}
	}

    if (!defined($color)) {
	$color = { 'type' => 'hot' };
    }
	    
    my(%rowSpec) = (volume => $volume,
		    color  => $color,
                    title  => $title);
	$rowSpec{'volume_overlay'} = $volume_overlays if defined($volume_overlays);
	$rowSpec{'surface_overlay'} = $surface_overlays if defined($surface_overlays);

    push(@RowSpec, \%rowSpec);
    
    return 1;
}

sub ParseColOption {
    my($opt, $args, $dest) = @_;

    $DefaultColsUsed = 0;

    @$dest = split(',', shift @$args);
}

sub ConvertColorSpec {
    my($colorSpec, $volume) = @_;

    if ($$colorSpec{'type'} =~ /gr[ae]y/) {
	$$colorSpec{'map'} = Gray_scale;
    }
    elsif ($$colorSpec{'type'} =~ /hot/) {
	$$colorSpec{'map'} = Hot_metal_scale;
    }
    elsif ($$colorSpec{'type'} =~ /spect/) {
	$$colorSpec{'map'} = Spectral_scale;
    }
    elsif ($$colorSpec{'type'} =~ /label/) {
	$$colorSpec{'map'} = Usercc_scale;
	$$colorSpec{'file'} = "${ModelDir}labels.map";
    }
    elsif (-f $$colorSpec{type}) {
	$$colorSpec{'file'} = $$colorSpec{'type'};
	$$colorSpec{'type'} = 'file';
	$$colorSpec{'map'}  = Usercc_scale;
    }

	# because of the way options are specified on the cmd line, we're stuck with
	# variables that can hold very different data:
	#   - min/max intensity, or
	#   - mask/label
	#
	# for the 2nd case, $$colorSpec{'min'}=>mask and $$colorSpec{'max'}->label
	my @extrema = VolumeRange($volume, $$colorSpec{'min'}, $$colorSpec{'max'});
	$$colorSpec{'min'} = $extrema[0];
	$$colorSpec{'max'} = $extrema[1];
}

sub VolumeRange {
    my($volume) = shift;
	my($mask) = shift; # if $_;
	my($bin_value) = shift; # if $_;

	my($cmd, $min, $max);

	# if not a number, treat as a mask file
	if ( defined($mask) and $mask !~ /[0-9]+(\.[0-9])?/ ){
		if (defined($mask) and IsMincVolume($mask)){
			my $mask_range;
			$bin_value = 1 if $bin_value !~ /[0-9]+(\.[0-9])?/;

			$cmd = "mincstats -quiet -mask $mask -mask_binvalue $bin_value -pctT 0.1 $volume";
			$min = `$cmd 2>&1`;
			die "\nError executing \"$cmd\": $min" if $?;

			$cmd = "mincstats -quiet -mask $mask -mask_binvalue $bin_value -pctT 99.9 $volume";
			$max = `$cmd 2>&1`;
			die "\nError executing \"$cmd\": $max" if $?;

			chomp ($min, $max);
		}
		else{ die "Mask '$mask' for color specification either does not exist or is not a minc volume.\n"; }
	}
	# else either min/max is given, or we need to calulate them with mincstats
	else{
		if ( defined($mask) ){ $min = $mask; }
		else{ 
			my $cmd = "mincstats -quiet -pctT 0.1 $volume";
			$min = `$cmd 2>&1`;
			die "Error executing \"$cmd\": $min" if $?;
			chomp $min;
		}

		if ( defined($bin_value) and $bin_value =~ /[0-9]+(\.[0-9])?/ ){ $max = $bin_value; }
		else{
			$cmd = "mincstats -quiet -pctT 99.9 $volume";
			$max = `$cmd 2>&1`;
			die "Error executing \"$cmd\": $max" if $?;
			chomp $max
		}
	}

	return ($min, $max);
}

sub ColorObject {
    my($obj, $color) = @_;

    if (defined($color)) {
	#my($temp) = $TmpDir . "/" . fileparse($obj);
	my($temp) = get_tmp_file( "obj" );
	#$temp =~ s/\.(gz|z|Z)$//;
	#$temp .= "_" . $color; 
	#$temp .= "_" while (-e $temp);
	&Run("set_object_colour $obj $temp '$color'");
	$obj = $temp;
    }

    return $obj;
}

sub HashToStr {
    my($href) = @_;
    my($key);
    my($string);
    foreach $key (keys %$href) {
	if (!defined($string)) {
	    $string = "$key: $$href{$key}";
	}
	else {
 	    $string .= " $key: $$href{$key}";
	}
    }

    $string;
}

sub IsMincVolume {
    my($volume) = @_;
    
    return (($volume =~ /\.mnc/) && (-f $volume));
}
	
# ------------------------------ MNI Header ----------------------------------
#@NAME       : &Uncompress
#@INPUT      : $tmp_dir - directory to uncompress files to
#              @originals - list of files to consider for uncompression
#@OUTPUT     :
#@RETURNS    : array context: @originals, changed so that any the names
#                of any files that were compressed are now decompressed
#                and in $tmp_dir
#              scalar context: first element of @originals, possibly changed
#                to decompressed version
#@DESCRIPTION: Uncompresses (if applicable) compressed files to $tmp_dir.
#@METHOD     :
#@GLOBALS    :
#@CALLS      :
#@CREATED    : 1995/07/31, Greg Ward
#@MODIFIED   :
#-----------------------------------------------------------------------------
sub Uncompress
{
    my ($tmp_dir, @originals) = @_;
    my ($uncompressed, @uncompressed, $orig);
    
    foreach $orig (@originals)
    {
	if ($orig =~ /\.(Z|gz|z)$/)
	{
	    $uncompressed = $tmp_dir . "/" . fileparse($orig);
	    $uncompressed =~ s/\.(Z|gz|z)$//;
	    unless (-e $uncompressed)
	    {
		&Run("gunzip -c $orig > $uncompressed");
	    }
	    push (@uncompressed, $uncompressed);
	}
	else
	{
	    push (@uncompressed, $orig);
	}
    }
    return @uncompressed if wantarray;
    return $uncompressed[0];
}

sub VolumeBounds {
    my ($volume, $start, $stop) = @_;

    # Some code adapted from autocrop
    my $cmd = "mincinfo $volume -error_string 0 " .
	"-attval xspace:start -attval xspace:step -dimlen xspace " .
	"-attval yspace:start -attval yspace:step -dimlen yspace " .
	"-attval zspace:start -attval zspace:step -dimlen zspace";
    my $diminfo = `$cmd`;
    die "Error executing \"$cmd\" on $volume\n" if $?;
    my @diminfo = split (/\n/, $diminfo);
    chomp @diminfo;

    my @volstart  = @diminfo[0,3,6];
    my @volstep   = @diminfo[1,4,7];
    my @vollength = @diminfo[2,5,8];
    my @volstop;

    foreach my $i (0, 1, 2) {
	$volstop[$i] = $volstart[$i] + $volstep[$i] * ($vollength[$i] - 1);
	($volstop[$i],$volstart[$i]) = ($volstart[$i],$volstop[$i])
	    if ($volstep[$i] < 0.0);
	
	my $dim = (qw(xspace yspace zspace))[$i];

	if ($Debug) {
	    printf "   %s: start=%g, stop=%g\n", $dim,$volstart[$i],$volstop[$i];
	}

	if (! defined $$start[$i]) {
	    $$start[$i] = $volstart[$i];
	}
	else {
	    $$start[$i] = $volstart[$i] if ($volstart[$i] > $$start[$i]);
	}

	if (! defined $$stop[$i]) {
	    $$stop[$i] = $volstop[$i];
	}
	else {
	    $$stop[$i] = $volstop[$i] if ($volstop[$i] < $$stop[$i]);
	}

	if ($Debug) {
	    printf "BB %s: start=%g, stop=%g\n", $dim,$$start[$i],$$stop[$i];
	}

	die "Unable to determine a useable bounding box (try -debug for more information)\n"
	    if ($$start[$i] > $$stop[$i]);
    }
}

sub Run {
    my(@cmd) = @_;

    print "@cmd\n" if ($Verbose);
    
    my $exit = 0;
    
    if ($Execute) {
        $exit = system(@cmd);
        warn "@cmd failed: $?\n" if $exit;
    }

    return $exit;
}

# reads color map from file specified and returns a hash of <label> => <color>
# TODO is there a standard hook for this that we could be using?
sub loadColorMap {
	my($file) = shift;

	my(%cm);

	my $fh = new IO::File $file;
	die "Unable to open color map'$file'\n" if (! defined $fh);

	LINE:
	while (<$fh>) {
		next LINE if /^\#/;

		# <label> <R> <G> <B> 
		next LINE if ! /^\s+(\d+)\s+([\.0-9]+)\s+([\.0-9]+)\s+([\.0-9]+)/;

		# simple sanity check
		if ( $2 > 1 or $3 > 1 or $4 > 1 ){
			die "Error parsing color map '$file': $1 $2 $3 $4 must each be in range (0,1).\n";
		}
		else{
			$cm{$1} = "$2 $3 $4";
		}
	}
	$fh->close;
	return %cm;
}

# generate a line width based on min step size for volume and an estimated
# scaling factor from native dimension to verification image
sub LineWidth {
   my $vol = shift;

   # [y-step, x-step, x-step, y-length, x-length, z-length]
   my $cmd = "mincinfo -attvalue yspace:step -attvalue xspace:step -attvalue zspace:step -attvalue yspace:length -attvalue xspace:length -attvalue zspace:length $vol";
   my @mincinfo = `$cmd`;
   chomp @mincinfo;

   my $minstep = min(@mincinfo[0..2]);
   $minstep = abs( $minstep );

   # get an estimate of scaling factor
   my $scale;

   if ( $Height ){
	   my $native_h_estimate = max( ($mincinfo[3], $mincinfo[4], $mincinfo[5]) ) * $n_rows;
	   $scale = $Height / $native_h_estimate if $Height;
   }
   elsif ( $Width ){
	   # transverse slice has width of coronal axis
	   $mincinfo[5] = $mincinfo[4];

	   my $native_w_estimate = 0;
	   foreach my $col (@ColSpec){
		   #$$col[0] is axis of slice: 0->s  1->c  2->t
		   $native_w_estimate += $mincinfo[$$col[0]+3];
	   }
	   $scale = $Width / $native_w_estimate if $Width;
   }

   # based on experiment: feel free to tinker if you don't like this function
   return (2.71828 ** ( (-0.79 * $scale) + 0.353 )) * $minstep;
}

# generate a color map (255 labels) for specs on cmd line. The map is written to
# a tmp file. The return value is the filename of the color map.
sub generate_color_map{
	my $color_spec = shift;
	my $filename = get_tmp_file( "map" );

	my %default_color_map;
	my %cmd_line_color_map;
	my @cmd_line_unlabeled;

	foreach my $color_def (split( ',', $color_spec)){
		my @def = split( ':', $color_def);
		if ( @def == 1 ){
			push( @cmd_line_unlabeled, $def[0] );
		}elsif ( @def == 2 ){
			$cmd_line_color_map{$def[0]} = $def[1];
		}else{
			die "Something went terribly wrong with your color specification!";
		}
	}

	my $color;
	my $map = " 0 0 0 0\n";
	foreach my $label (1 .. 254){

		#look for a user-defined color
		$color = $cmd_line_color_map{$label};
		$color = shift @cmd_line_unlabeled if not defined $color;

		# if can't find one, grab defualt color
		if ( not defined $color ){
			%default_color_map = loadColorMap("${ModelDir}labels.map") if not %default_color_map;
			$color = $default_color_map{$label};
		}

		$map .= " $label $color\n";
	}
	$map .= " 255 0 0 0\n";

	my $fh = new IO::File "> $filename";
	print $fh $map;
	$fh->close;

	return $filename;
}
